import{buildOr as n,buildAnd as t,CompoundCondition as r}from"@ucast/mongo2js";function e(n){return Array.isArray(n)?n:[n]}function o(n,t,r){let e=n;let o=t;if(-1!==t.indexOf(".")){const r=t.split(".");o=r.pop();e=r.reduce(((n,t)=>{n[t]=n[t]||{};return n[t]}),n)}e[o]=r}function c(n,t,r,e){const o={};const c=n.rulesFor(t,r);for(let n=0;n<c.length;n++){const t=c[n];const r=t.inverted?"$and":"$or";if(!t.conditions)if(t.inverted)break;else{delete o[r];return o}else{o[r]=o[r]||[];o[r].push(e(t))}}return o.$or?o:null}function u(n){if(!n.ast)throw new Error(`Ability rule "${JSON.stringify(n)}" does not have "ast" property. So, cannot be used to generate AST`);return n.inverted?new r("not",[n.ast]):n.ast}function i(r,e,o){const i=c(r,e,o,u);if(null===i)return null;if(!i.$and)return i.$or?n(i.$or):t([]);if(i.$or)i.$and.push(n(i.$or));return t(i.$and)}function f(n,t,r){return n.rulesFor(t,r).reduce(((n,t)=>{if(t.inverted||!t.conditions)return n;return Object.keys(t.conditions).reduce(((n,r)=>{const e=t.conditions[r];if(!e||e.constructor!==Object)o(n,r,e);return n}),n)}),{})}function s(n,t,r,e){const o=n.detectSubjectType(r);const c=n.possibleRulesFor(t,o);const u=new Set;const i=u.delete.bind(u);const f=u.add.bind(u);let s=c.length;while(s--){const n=c[s];if(n.matchesConditions(r)){const t=n.inverted?i:f;e.fieldsFrom(n).forEach(t)}}return Array.from(u)}const l=n=>Array.isArray(n)?n.join(","):n;function a(n,t){return n.map((n=>{const r=[l(n.action||n.actions),"function"===typeof t?e(n.subject).map(t).join(","):l(n.subject),n.conditions||0,n.inverted?1:0,n.fields?l(n.fields):0,n.reason||""];while(!r[r.length-1])r.pop();return r}))}function y(n,t){return n.map((([n,r,e,o,c,u])=>{const i=r.split(",");const f={inverted:!!o,action:n.split(","),subject:"function"===typeof t?i.map(t):i};if(e)f.conditions=e;if(c)f.fields=c.split(",");if(u)f.reason=u;return f}))}export{a as packRules,s as permittedFieldsOf,i as rulesToAST,f as rulesToFields,c as rulesToQuery,y as unpackRules};
//# sourceMappingURL=extra.mjs.map
