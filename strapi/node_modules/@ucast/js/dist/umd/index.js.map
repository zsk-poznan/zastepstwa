{"version":3,"file":"index.js","sources":["../../src/utils.ts","../../src/interpreter.ts","../../src/interpreters.ts","../../src/defaults.ts"],"sourcesContent":["import { FieldCondition } from '@ucast/core';\nimport { JsInterpretationOptions, JsInterpreter } from './types';\n\nexport type AnyObject = Record<PropertyKey, unknown>;\nexport type GetField = (object: any, field: string) => any;\n\nexport function includes<T>(\n  items: T[],\n  value: T,\n  compare: JsInterpretationOptions['compare']\n): boolean {\n  for (let i = 0, length = items.length; i < length; i++) {\n    if (compare(items[i], value) === 0) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexport function isArrayAndNotNumericField<T>(object: T | T[], field: string): object is T[] {\n  return Array.isArray(object) && Number.isNaN(Number(field));\n}\n\nfunction getField<T extends AnyObject>(object: T | T[], field: string, get: GetField) {\n  if (!isArrayAndNotNumericField(object, field)) {\n    return get(object, field);\n  }\n\n  let result: unknown[] = [];\n\n  for (let i = 0; i < object.length; i++) {\n    const value = get(object[i], field);\n    if (typeof value !== 'undefined') {\n      result = result.concat(value);\n    }\n  }\n\n  return result;\n}\n\nexport function getValueByPath(object: AnyObject, field: string, get: GetField) {\n  if (field.indexOf('.') === -1) {\n    return getField(object, field, get);\n  }\n\n  const paths = field.split('.');\n  let value = object;\n\n  for (let i = 0, length = paths.length; i < length; i++) {\n    value = getField(value, paths[i], get);\n\n    if (!value || typeof value !== 'object') {\n      return value;\n    }\n  }\n\n  return value;\n}\n\nexport function testValueOrArray<T, U = T>(test: JsInterpreter<FieldCondition<T>, U>) {\n  return ((node, object, context) => {\n    const value = context.get(object, node.field);\n\n    if (!Array.isArray(value)) {\n      return test(node, value, context);\n    }\n\n    return value.some(v => test(node, v, context));\n  }) as JsInterpreter<FieldCondition<T>, AnyObject | U>;\n}\n","import { createInterpreter, ITSELF } from '@ucast/core';\nimport { getValueByPath, AnyObject, GetField } from './utils';\nimport { JsInterpretationOptions, JsInterpreter } from './types';\n\nconst defaultGet = (object: AnyObject, field: string) => object[field];\ntype Field = string | typeof ITSELF;\n\nexport function getObjectFieldCursor<T extends {}>(object: T, path: string, get: GetField) {\n  const dotIndex = path.lastIndexOf('.');\n\n  if (dotIndex === -1) {\n    return [object, path] as const;\n  }\n\n  return [\n    get(object, path.slice(0, dotIndex)) as T,\n    path.slice(dotIndex + 1)\n  ] as const;\n}\n\nexport function getObjectField(object: unknown, field: Field, get: GetField = defaultGet) {\n  if (field === ITSELF) {\n    return object;\n  }\n\n  if (!object) {\n    throw new Error(`Unable to get field \"${field}\" out of ${String(object)}.`);\n  }\n\n  return getValueByPath(object as Record<string, unknown>, field, get);\n}\n\nexport function createGetter<T extends GetField>(get: T) {\n  return (object: Parameters<T>[0], field: Parameters<T>[1]) => getObjectField(object, field, get);\n}\n\nexport function compare<T>(a: T, b: T): 0 | 1 | -1 {\n  if (a === b) {\n    return 0;\n  }\n\n  return a > b ? 1 : -1;\n}\n\nexport function createJsInterpreter<\n  T extends JsInterpreter<any>,\n  O extends Partial<JsInterpretationOptions>\n>(\n  operators: Record<string, T>,\n  options: O = {} as O\n) {\n  return createInterpreter(operators, {\n    get: getObjectField,\n    compare,\n    ...options,\n  });\n}\n","import {\n  CompoundCondition as Compound,\n  FieldCondition as Field,\n  DocumentCondition as Document,\n  Condition,\n  Comparable,\n  ITSELF,\n} from '@ucast/core';\nimport { JsInterpreter as Interpret } from './types';\nimport {\n  includes,\n  testValueOrArray,\n  isArrayAndNotNumericField,\n  AnyObject,\n} from './utils';\nimport { getObjectFieldCursor } from './interpreter';\n\nexport const or: Interpret<Compound> = (node, object, { interpret }) => {\n  return node.value.some(condition => interpret(condition, object));\n};\n\nexport const nor: typeof or = (node, object, context) => {\n  return !or(node, object, context);\n};\n\nexport const and: Interpret<Compound> = (node, object, { interpret }) => {\n  return node.value.every(condition => interpret(condition, object));\n};\n\nexport const not: Interpret<Compound> = (node, object, { interpret }) => {\n  return !interpret(node.value[0], object);\n};\n\nexport const eq: Interpret<Field> = (node, object, { compare, get }) => {\n  const value = get(object, node.field);\n\n  if (Array.isArray(value) && !Array.isArray(node.value)) {\n    return includes(value, node.value, compare);\n  }\n\n  return compare(value, node.value) === 0;\n};\n\nexport const ne: typeof eq = (node, object, context) => {\n  return !eq(node, object, context);\n};\n\nexport const lte = testValueOrArray<Comparable>((node, value, context) => {\n  const result = context.compare(value, node.value);\n  return result === 0 || result === -1;\n});\n\nexport const lt = testValueOrArray<Comparable>((node, value, context) => {\n  return context.compare(value, node.value) === -1;\n});\nexport const gt = testValueOrArray<Comparable>((node, value, context) => {\n  return context.compare(value, node.value) === 1;\n});\nexport const gte = testValueOrArray<Comparable>((node, value, context) => {\n  const result = context.compare(value, node.value);\n  return result === 0 || result === 1;\n});\n\nexport const exists: Interpret<Field<boolean>> = (node, object, { get }) => {\n  if (node.field === ITSELF) {\n    return typeof object !== 'undefined';\n  }\n\n  const [item, field] = getObjectFieldCursor<{}>(object, node.field, get);\n  const test = (value: {}) => !!value && value.hasOwnProperty(field) === node.value;\n\n  return isArrayAndNotNumericField(item, field) ? item.some(test) : test(item);\n};\n\nexport const mod = testValueOrArray<[number, number], number>((node, value) => {\n  return typeof value === 'number' && value % node.value[0] === node.value[1];\n});\n\nexport const size: Interpret<Field<number>, AnyObject | unknown[]> = (node, object, { get }) => {\n  const [items, field] = getObjectFieldCursor(object as AnyObject, node.field, get);\n  const test = (item: unknown) => {\n    const value = get(item, field);\n    return Array.isArray(value) && value.length === node.value;\n  };\n\n  return node.field !== ITSELF && isArrayAndNotNumericField(items, field)\n    ? items.some(test)\n    : test(items);\n};\n\nexport const regex = testValueOrArray<RegExp, string>((node, value) => {\n  return typeof value === 'string' && node.value.test(value);\n});\n\nexport const within = testValueOrArray<unknown[], unknown>((node, object, { compare }) => {\n  return includes(node.value, object, compare);\n});\n\nexport const nin: typeof within = (node, object, context) => !within(node, object, context);\n\nexport const all: Interpret<Field<unknown[]>> = (node, object, { compare, get }) => {\n  const value = get(object, node.field);\n  return Array.isArray(value) && node.value.every(v => includes(value, v, compare));\n};\n\nexport const elemMatch: Interpret<Field<Condition>> = (node, object, { interpret, get }) => {\n  const value = get(object, node.field);\n  return Array.isArray(value) && value.some(v => interpret(node.value, v));\n};\n\ntype WhereFunction = (this: AnyObject) => boolean;\nexport const where: Interpret<Document<WhereFunction>, AnyObject> = (node, object) => {\n  return node.value.call(object);\n};\n","import { createJsInterpreter } from './interpreter';\nimport * as interpreters from './interpreters';\n\nexport const allInterpreters = {\n  ...interpreters,\n  in: interpreters.within,\n};\nexport const interpret = createJsInterpreter(allInterpreters);\n"],"names":["includes","items","value","compare","i","length","isArrayAndNotNumericField","object","field","Array","isArray","Number","isNaN","getField","get","result","concat","testValueOrArray","test","node","context","some","v","defaultGet","getObjectFieldCursor","path","dotIndex","lastIndexOf","slice","getObjectField","ITSELF","Error","String","indexOf","paths","split","getValueByPath","a","b","createJsInterpreter","operators","options","createInterpreter","or","interpret","condition","nor","and","every","not","eq","ne","lte","lt","gt","gte","exists","item","hasOwnProperty","mod","size","regex","within","nin","all","elemMatch","where","call","allInterpreters","in","interpreters"],"mappings":"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"}