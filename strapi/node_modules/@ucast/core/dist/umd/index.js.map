{"version":3,"file":"index.js","sources":["../../src/Condition.ts","../../src/utils.ts","../../src/builder.ts","../../src/parsers/defaultInstructionParsers.ts","../../src/parsers/ObjectQueryParser.ts","../../src/interpreter.ts","../../src/index.ts","../../src/translator.ts"],"sourcesContent":["export interface Note<T> {\n  type: string\n  message?: string\n  originalValue?: T\n}\n\nexport abstract class Condition<T = unknown> {\n  private _notes!: Note<T>[];\n\n  constructor(\n    public readonly operator: string,\n    public readonly value: T\n  ) {\n    Object.defineProperty(this, '_notes', {\n      writable: true\n    });\n  }\n\n  get notes(): ReadonlyArray<Note<T>> | undefined {\n    return this._notes;\n  }\n\n  addNote(note: Note<T>) {\n    this._notes = this._notes || [];\n    this._notes.push(note);\n  }\n}\n\nexport class DocumentCondition<T> extends Condition<T> {\n}\n\nexport class CompoundCondition<T extends Condition = Condition> extends DocumentCondition<T[]> {\n  constructor(operator: string, conditions: T[]) {\n    if (!Array.isArray(conditions)) {\n      throw new Error(`\"${operator}\" operator expects to receive an array of conditions`);\n    }\n\n    super(operator, conditions);\n  }\n}\n\nexport const ITSELF = '__itself__';\nexport class FieldCondition<T = unknown> extends Condition<T> {\n  public readonly field!: string | typeof ITSELF;\n\n  constructor(operator: string, field: string | typeof ITSELF, value: T) {\n    super(operator, value);\n    this.field = field;\n  }\n}\n\nexport const NULL_CONDITION = new DocumentCondition('__null__', null);\nexport type ConditionValue<T> = T extends Condition<infer V> ? V : unknown;\n","import { Condition, CompoundCondition, NULL_CONDITION } from './Condition';\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty.call.bind(Object.prototype.hasOwnProperty);\n\nexport function isCompound(operator: string, condition: Condition): condition is CompoundCondition {\n  return condition instanceof CompoundCondition && condition.operator === operator;\n}\n\nfunction flattenConditions<T extends Condition>(\n  operator: string,\n  conditions: T[],\n  aggregatedResult?: T[]\n) {\n  const flatConditions: T[] = aggregatedResult || [];\n\n  for (let i = 0, length = conditions.length; i < length; i++) {\n    const currentNode = conditions[i];\n\n    if (isCompound(operator, currentNode)) {\n      flattenConditions(operator, currentNode.value as T[], flatConditions);\n    } else {\n      flatConditions.push(currentNode);\n    }\n  }\n\n  return flatConditions;\n}\n\nexport function optimizedCompoundCondition<T extends Condition>(operator: string, conditions: T[]) {\n  if (conditions.length === 1) {\n    return conditions[0];\n  }\n\n  return new CompoundCondition(operator, flattenConditions(operator, conditions));\n}\n\nexport const identity = <T>(x: T) => x;\nexport const object = () => Object.create(null);\n\nexport const ignoreValue: IgnoreValue = Object.defineProperty(object(), '__@type@__', {\n  value: 'ignore value'\n});\nexport interface IgnoreValue {\n  readonly ['__@type@__']: 'ignore value'\n}\n\nexport function hasOperators<T>(\n  value: any,\n  instructions: Record<string, unknown>,\n  skipIgnore = false,\n): value is T {\n  if (!value || value && value.constructor !== Object) {\n    return false;\n  }\n\n  for (const prop in value) { // eslint-disable-line no-restricted-syntax, guard-for-in\n    const hasProp = hasOwnProperty(value, prop) && hasOwnProperty(instructions, prop);\n    if (hasProp && (!skipIgnore || value[prop] !== ignoreValue)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexport function objectKeysSkipIgnore(anyObject: Record<string, unknown>) {\n  const keys: string[] = [];\n  for (const key in anyObject) { // eslint-disable-line no-restricted-syntax\n    if (hasOwnProperty(anyObject, key) && anyObject[key] !== ignoreValue) {\n      keys.push(key);\n    }\n  }\n\n  return keys;\n}\n\nexport function pushIfNonNullCondition(conditions: Condition[], condition: Condition) {\n  if (condition !== NULL_CONDITION) {\n    conditions.push(condition);\n  }\n}\n","import { Condition } from './Condition';\nimport { optimizedCompoundCondition } from './utils';\n\nexport const buildAnd = (conditions: Condition[]) => optimizedCompoundCondition('and', conditions);\nexport const buildOr = (conditions: Condition[]) => optimizedCompoundCondition('or', conditions);\n","import {\n  FieldCondition,\n  CompoundCondition,\n  DocumentCondition,\n} from '../Condition';\nimport {\n  DocumentInstruction,\n  CompoundInstruction,\n  FieldInstruction,\n} from '../types';\n\ninterface DefaultParsers {\n  compound: Exclude<CompoundInstruction['parse'], undefined>,\n  field: Exclude<FieldInstruction['parse'], undefined>,\n  document: Exclude<DocumentInstruction['parse'], undefined>\n}\n\nexport const defaultInstructionParsers: DefaultParsers = {\n  compound(instruction, value, context) {\n    const queries = Array.isArray(value) ? value : [value];\n    const conditions = queries.map(query => context.parse(query));\n    return new CompoundCondition(instruction.name, conditions);\n  },\n  field(instruction, value, context) {\n    return new FieldCondition(instruction.name, context.field, value);\n  },\n  document(instruction, value) {\n    return new DocumentCondition(instruction.name, value);\n  }\n};\n","import { Condition } from '../Condition';\nimport {\n  NamedInstruction,\n  ParsingInstruction,\n  FieldParsingContext,\n  ParsingContext,\n} from '../types';\nimport { buildAnd } from '../builder';\nimport { defaultInstructionParsers } from './defaultInstructionParsers';\nimport {\n  identity,\n  hasOperators,\n  object,\n  pushIfNonNullCondition,\n  objectKeysSkipIgnore,\n} from '../utils';\n\nexport type FieldQueryOperators<T extends {}> = {\n  [K in keyof T]: T[K] extends {} ? T[K] : never\n}[keyof T];\n\ntype ParsingInstructions = Record<string, NamedInstruction>;\n\nexport interface QueryOptions {\n  operatorToConditionName?(name: string): string\n  defaultOperatorName?: string\n  fieldContext?: Record<string, unknown>\n  documentContext?: Record<string, unknown>\n  useIgnoreValue?: boolean\n  mergeFinalConditions?(conditions: Condition[]): Condition\n}\n\nexport type ObjectQueryFieldParsingContext = ParsingContext<FieldParsingContext & {\n  query: {},\n  hasOperators<T>(value: unknown): value is T\n}>;\n\nexport class ObjectQueryParser<\n  T extends Record<any, any>,\n  U extends FieldQueryOperators<T> = FieldQueryOperators<T>\n> {\n  private readonly _instructions: ParsingInstructions;\n  private _fieldInstructionContext: ObjectQueryFieldParsingContext;\n  private _documentInstructionContext: ParsingContext<{ query: {} }>;\n  private readonly _options: Required<\n  Pick<QueryOptions, 'operatorToConditionName' | 'defaultOperatorName' | 'mergeFinalConditions'>\n  >;\n\n  private readonly _objectKeys: typeof Object.keys;\n\n  constructor(instructions: Record<string, ParsingInstruction>, options: QueryOptions = object()) {\n    this.parse = this.parse.bind(this);\n    this._options = {\n      operatorToConditionName: options.operatorToConditionName || identity,\n      defaultOperatorName: options.defaultOperatorName || 'eq',\n      mergeFinalConditions: options.mergeFinalConditions || buildAnd,\n    };\n    this._instructions = Object.keys(instructions).reduce((all, name) => {\n      all[name] = { name: this._options.operatorToConditionName(name), ...instructions[name] };\n      return all;\n    }, {} as ParsingInstructions);\n    this._fieldInstructionContext = {\n      ...options.fieldContext,\n      field: '',\n      query: {},\n      parse: this.parse,\n      hasOperators: <T>(value: unknown): value is T => hasOperators(\n        value,\n        this._instructions,\n        options.useIgnoreValue\n      ),\n    };\n    this._documentInstructionContext = {\n      ...options.documentContext,\n      parse: this.parse,\n      query: {}\n    };\n    this._objectKeys = options.useIgnoreValue ? objectKeysSkipIgnore : Object.keys;\n  }\n\n  setParse(parse: this['parse']) {\n    this.parse = parse;\n    this._fieldInstructionContext.parse = parse;\n    this._documentInstructionContext.parse = parse;\n  }\n\n  protected parseField(field: string, operator: string, value: unknown, parentQuery: {}) {\n    const instruction = this._instructions[operator];\n\n    if (!instruction) {\n      throw new Error(`Unsupported operator \"${operator}\"`);\n    }\n\n    if (instruction.type !== 'field') {\n      throw new Error(`Unexpected ${instruction.type} operator \"${operator}\" at field level`);\n    }\n\n    this._fieldInstructionContext.field = field;\n    this._fieldInstructionContext.query = parentQuery;\n\n    return this.parseInstruction(instruction, value, this._fieldInstructionContext);\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  protected parseInstruction(\n    instruction: NamedInstruction,\n    value: unknown,\n    context: ParsingContext<{}>\n  ) {\n    if (typeof instruction.validate === 'function') {\n      instruction.validate(instruction, value);\n    }\n\n    const parse: typeof instruction.parse = instruction.parse\n      || defaultInstructionParsers[instruction.type as keyof typeof defaultInstructionParsers];\n    return parse(instruction, value, context);\n  }\n\n  protected parseFieldOperators(field: string, value: U) {\n    const conditions: Condition[] = [];\n    const keys = this._objectKeys(value);\n\n    for (let i = 0, length = keys.length; i < length; i++) {\n      const op = keys[i];\n      const instruction = this._instructions[op];\n\n      if (!instruction) {\n        throw new Error(`Field query for \"${field}\" may contain only operators or a plain object as a value`);\n      }\n\n      const condition = this.parseField(field, op, value[op as keyof U], value);\n      pushIfNonNullCondition(conditions, condition);\n    }\n\n    return conditions;\n  }\n\n  parse<Q extends T>(query: Q): Condition {\n    const conditions = [];\n    const keys = this._objectKeys(query);\n\n    this._documentInstructionContext.query = query;\n\n    for (let i = 0, length = keys.length; i < length; i++) {\n      const key = keys[i];\n      const value = query[key];\n      const instruction = this._instructions[key];\n\n      if (instruction) {\n        if (instruction.type !== 'document' && instruction.type !== 'compound') {\n          throw new Error(`Cannot use parsing instruction for operator \"${key}\" in \"document\" context as it is supposed to be used in  \"${instruction.type}\" context`);\n        }\n\n        pushIfNonNullCondition(\n          conditions,\n          this.parseInstruction(instruction, value, this._documentInstructionContext)\n        );\n      } else if (this._fieldInstructionContext.hasOperators<U>(value)) {\n        conditions.push(...this.parseFieldOperators(key, value));\n      } else {\n        pushIfNonNullCondition(\n          conditions,\n          this.parseField(key, this._options.defaultOperatorName, value, query)\n        );\n      }\n    }\n\n    return this._options.mergeFinalConditions(conditions);\n  }\n}\n","import { Condition } from './Condition';\n\ntype ArgsExceptLast<F extends (...args: any[]) => any> =\n  F extends (a: any, c: any) => any\n    ? Parameters<(condition: Condition) => 0>\n    : F extends (a: any, b: any, c: any) => any\n      ? Parameters<(condition: Condition, value: Parameters<F>[1]) => 0>\n      : Parameters<(\n        condition: Condition,\n        value: Parameters<F>[1],\n        options: Parameters<F>[2],\n        ...args: unknown[]\n      ) => 0>;\n\nexport type Interpreter<T extends Condition, R> = (condition: T, ...args: any[]) => R;\nexport type AnyInterpreter = Interpreter<any, any>;\nexport interface InterpretationContext<T extends AnyInterpreter> {\n  interpret(...args: ArgsExceptLast<T>): ReturnType<T>;\n}\n\nfunction getInterpreter<T extends Record<string, AnyInterpreter>>(\n  interpreters: T,\n  operator: keyof T\n) {\n  const interpret = interpreters[operator];\n\n  if (typeof interpret !== 'function') {\n    throw new Error(`Unable to interpret \"${operator}\" condition. Did you forget to register interpreter for it?`);\n  }\n\n  return interpret;\n}\n\nexport interface InterpreterOptions {\n  numberOfArguments?: 1 | 2 | 3\n  getInterpreterName?(condition: Condition, context: this): string\n}\n\nfunction defaultInterpreterName(condition: Condition) {\n  return condition.operator;\n}\n\nexport function createInterpreter<T extends AnyInterpreter, U extends {} = {}>(\n  interpreters: Record<string, T>,\n  rawOptions?: U\n) {\n  const options = rawOptions as U & InterpreterOptions;\n  const getInterpreterName = options && options.getInterpreterName || defaultInterpreterName;\n  let interpret;\n\n  switch (options ? options.numberOfArguments : 0) {\n    case 1:\n      interpret = ((condition) => {\n        const interpreterName = getInterpreterName(condition, options);\n        const interpretOperator = getInterpreter(interpreters, interpreterName);\n        return interpretOperator(condition, defaultContext); // eslint-disable-line @typescript-eslint/no-use-before-define\n      }) as InterpretationContext<T>['interpret'];\n      break;\n    case 3:\n      interpret = ((condition, value, params) => {\n        const interpreterName = getInterpreterName(condition, options);\n        const interpretOperator = getInterpreter(interpreters, interpreterName);\n        return interpretOperator(condition, value, params, defaultContext); // eslint-disable-line @typescript-eslint/no-use-before-define\n      }) as InterpretationContext<T>['interpret'];\n      break;\n    default:\n      interpret = ((condition, value) => {\n        const interpreterName = getInterpreterName(condition, options);\n        const interpretOperator = getInterpreter(interpreters, interpreterName);\n        return interpretOperator(condition, value, defaultContext); // eslint-disable-line @typescript-eslint/no-use-before-define\n      }) as InterpretationContext<T>['interpret'];\n      break;\n  }\n\n  const defaultContext = {\n    ...options,\n    interpret,\n  } as InterpretationContext<T> & U;\n\n  return defaultContext.interpret;\n}\n","import { ObjectQueryParser } from './parsers/ObjectQueryParser';\n\nexport * from './Condition';\nexport * from './types';\nexport * from './interpreter';\nexport * from './translator';\nexport * from './builder';\nexport {\n  isCompound,\n  hasOperators,\n  identity,\n  object,\n  optimizedCompoundCondition,\n  ignoreValue,\n} from './utils';\nexport type {\n  IgnoreValue\n} from './utils';\nexport * from './parsers/ObjectQueryParser';\nexport * from './parsers/defaultInstructionParsers';\n/**\n * @deprecated use `ObjectQueryParser#parseInstruction` instead\n * TODO(major): remove\n */\nexport const parseInstruction = (ObjectQueryParser.prototype as any).parseInstruction;\n","import { Condition } from './Condition';\nimport { Parse } from './types';\nimport { AnyInterpreter } from './interpreter';\n\ntype Bound<T> = T extends (first: Condition, ...args: infer A) => any\n  ? { (...args: A): ReturnType<T>, ast: Condition }\n  : never;\n\nexport function createTranslatorFactory<Lang, Interpreter extends AnyInterpreter>(\n  parse: Parse<Lang>,\n  interpret: Interpreter\n) {\n  return (query: Lang, ...args: unknown[]): Bound<Interpreter> => {\n    const ast = parse(query, ...args);\n    const translate = (interpret as any).bind(null, ast);\n    translate.ast = ast;\n    return translate;\n  };\n}\n"],"names":["Condition","operator","value","Object","defineProperty","this","writable","addNote","note","_notes","push","DocumentCondition","CompoundCondition","conditions","Array","isArray","Error","_DocumentCondition","FieldCondition","field","NULL_CONDITION","hasOwnProperty","prototype","call","bind","isCompound","condition","optimizedCompoundCondition","length","flattenConditions","aggregatedResult","flatConditions","i","currentNode","identity","x","object","create","ignoreValue","hasOperators","instructions","skipIgnore","constructor","prop","objectKeysSkipIgnore","anyObject","keys","key","pushIfNonNullCondition","buildAnd","defaultInstructionParsers","compound","instruction","context","map","query","parse","name","document","ObjectQueryParser","options","_instructions","_fieldInstructionContext","_documentInstructionContext","_options","_objectKeys","operatorToConditionName","defaultOperatorName","mergeFinalConditions","reduce","all","_this","fieldContext","useIgnoreValue","documentContext","setParse","parseField","parentQuery","type","parseInstruction","validate","parseFieldOperators","op","getInterpreter","interpreters","interpret","defaultInterpreterName","rawOptions","getInterpreterName","numberOfArguments","interpreterName","interpretOperator","defaultContext","params","args","ast","translate"],"mappings":"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"}