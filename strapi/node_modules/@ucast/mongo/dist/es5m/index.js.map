{"version":3,"file":"index.js","sources":["../../src/instructions.ts","../../src/MongoQueryParser.ts","../../src/index.ts"],"sourcesContent":["import {\n  CompoundCondition,\n  FieldCondition,\n  NamedInstruction,\n  CompoundInstruction,\n  FieldInstruction,\n  DocumentInstruction,\n  Comparable,\n  ITSELF,\n  NULL_CONDITION,\n  FieldParsingContext,\n  optimizedCompoundCondition,\n  ObjectQueryFieldParsingContext,\n} from '@ucast/core';\nimport { MongoQuery } from './types';\n\nfunction ensureIsArray(instruction: NamedInstruction, value: unknown) {\n  if (!Array.isArray(value)) {\n    throw new Error(`\"${instruction.name}\" expects value to be an array`);\n  }\n}\n\nfunction ensureIsNonEmptyArray(instruction: NamedInstruction, value: unknown[]) {\n  ensureIsArray(instruction, value);\n\n  if (!value.length) {\n    throw new Error(`\"${instruction.name}\" expects to have at least one element in array`);\n  }\n}\n\nfunction ensureIsComparable(instruction: NamedInstruction, value: string | number | Date) {\n  const isComparable = typeof value === 'string' || typeof value === 'number' || value instanceof Date;\n\n  if (!isComparable) {\n    throw new Error(`\"${instruction.name}\" expects value to be comparable (i.e., string, number or date)`);\n  }\n}\n\nconst ensureIs = (type: string) => (instruction: NamedInstruction, value: unknown) => {\n  if (typeof value !== type) { // eslint-disable-line valid-typeof\n    throw new Error(`\"${instruction.name}\" expects value to be a \"${type}\"`);\n  }\n};\n\nexport const $and: CompoundInstruction<MongoQuery<any>[]> = {\n  type: 'compound',\n  validate: ensureIsNonEmptyArray,\n  parse(instruction, queries, { parse }) {\n    const conditions = queries.map(query => parse(query));\n    return optimizedCompoundCondition(instruction.name, conditions);\n  }\n};\nexport const $or = $and;\nexport const $nor: CompoundInstruction<MongoQuery<any>[]> = {\n  type: 'compound',\n  validate: ensureIsNonEmptyArray,\n};\n\nexport const $not: FieldInstruction<MongoQuery<any> | RegExp> = {\n  type: 'field',\n  validate(instruction, value) {\n    const isValid = value && (value instanceof RegExp || value.constructor === Object);\n\n    if (!isValid) {\n      throw new Error(`\"${instruction.name}\" expects to receive either regular expression or object of field operators`);\n    }\n  },\n  parse(instruction, value, context) {\n    const condition = value instanceof RegExp\n      ? new FieldCondition('regex' as typeof instruction.name, context.field, value)\n      : context.parse(value, context);\n\n    return new CompoundCondition(instruction.name, [condition]);\n  },\n};\nexport const $elemMatch: FieldInstruction<MongoQuery<any>, ObjectQueryFieldParsingContext> = {\n  type: 'field',\n  validate(instruction, value) {\n    if (!value || value.constructor !== Object) {\n      throw new Error(`\"${instruction.name}\" expects to receive an object with nested query or field level operators`);\n    }\n  },\n  parse(instruction, value, { parse, field, hasOperators }) {\n    const condition = hasOperators(value) ? parse(value, { field: ITSELF }) : parse(value);\n    return new FieldCondition(instruction.name, field, condition);\n  }\n};\n\nexport const $size: FieldInstruction<number> = {\n  type: 'field',\n  validate: ensureIs('number')\n};\nexport const $in: FieldInstruction<unknown[]> = {\n  type: 'field',\n  validate: ensureIsArray,\n};\nexport const $nin = $in;\nexport const $all = $in;\nexport const $mod: FieldInstruction<[number, number]> = {\n  type: 'field',\n  validate(instruction, value) {\n    if (!Array.isArray(value) || value.length !== 2) {\n      throw new Error(`\"${instruction.name}\" expects an array with 2 numeric elements`);\n    }\n  }\n};\n\nexport const $exists: FieldInstruction<boolean> = {\n  type: 'field',\n  validate: ensureIs('boolean'),\n};\n\nexport const $gte: FieldInstruction<Comparable> = {\n  type: 'field',\n  validate: ensureIsComparable\n};\nexport const $gt = $gte;\nexport const $lt = $gt;\nexport const $lte = $gt;\n\nexport const $eq: FieldInstruction = {\n  type: 'field',\n};\nexport const $ne = $eq;\n\nexport interface RegExpFieldContext extends FieldParsingContext {\n  query: {\n    $options?: string\n  }\n}\n\nexport const $regex: FieldInstruction<string | RegExp, RegExpFieldContext> = {\n  type: 'field',\n  validate(instruction, value) {\n    if (!(value instanceof RegExp) && typeof value !== 'string') {\n      throw new Error(`\"${instruction.name}\" expects value to be a regular expression or a string that represents regular expression`);\n    }\n  },\n  parse(instruction, rawValue, context) {\n    const value = typeof rawValue === 'string'\n      ? new RegExp(rawValue, context.query.$options || '')\n      : rawValue;\n    return new FieldCondition(instruction.name, context.field, value);\n  }\n};\nexport const $options: FieldInstruction = {\n  type: 'field',\n  parse: () => NULL_CONDITION,\n};\n\nexport const $where: DocumentInstruction<() => boolean> = {\n  type: 'document',\n  validate: ensureIs('function'),\n};\n","import {\n  Condition,\n  buildAnd as and,\n  ParsingInstruction,\n  ObjectQueryParser,\n  FieldQueryOperators,\n} from '@ucast/core';\nimport { MongoQuery } from './types';\n\nexport interface ParseOptions {\n  field: string\n}\n\nexport class MongoQueryParser extends ObjectQueryParser<MongoQuery<any>> {\n  constructor(instructions: Record<string, ParsingInstruction>) {\n    super(instructions, {\n      defaultOperatorName: '$eq',\n      operatorToConditionName: name => name.slice(1),\n    });\n  }\n\n  parse<Q extends MongoQuery<any>, FQ extends FieldQueryOperators<Q> = FieldQueryOperators<Q>>(\n    query: Q | FQ,\n    options?: ParseOptions\n  ): Condition {\n    if (options && options.field) {\n      return and(this.parseFieldOperators(options.field, query as FQ));\n    }\n\n    return super.parse(query);\n  }\n}\n","import * as instructions from './instructions';\n\nexport const allParsingInstructions = instructions;\nexport * from './instructions';\nexport * from './MongoQueryParser';\nexport * from './types';\nexport { defaultInstructionParsers as defaultParsers } from '@ucast/core';\n"],"names":["ensureIsArray","instruction","value","Array","isArray","Error","name","ensureIsNonEmptyArray","length","ensureIs","type","$and","validate","parse","queries","conditions","map","query","optimizedCompoundCondition","$or","$nor","$not","RegExp","constructor","Object","context","condition","FieldCondition","field","CompoundCondition","$elemMatch","hasOperators","ITSELF","$size","$in","$nin","$all","$mod","$exists","$gte","Date","$gt","$lt","$lte","$eq","$ne","$regex","rawValue","$options","NULL_CONDITION","$where","MongoQueryParser","instructions","_ObjectQueryParser","defaultOperatorName","operatorToConditionName","slice","options","and","this","parseFieldOperators","ObjectQueryParser","allParsingInstructions"],"mappings":"8OAgBA,SAASA,EAAcC,EAA+BC,OAC/CC,MAAMC,QAAQF,SACX,IAAIG,UAAUJ,EAAYK,uCAIpC,SAASC,EAAsBN,EAA+BC,MAC5DF,EAAcC,EAAaC,IAEtBA,EAAMM,aACH,IAAIH,UAAUJ,EAAYK,wDAYpC,IAAMG,EAAW,SAACC,UAAiB,SAACT,EAA+BC,aACtDA,IAAUQ,QACb,IAAIL,UAAUJ,EAAYK,iCAAgCI,SAIvDC,EAA+C,CAC1DD,KAAM,WACNE,SAAUL,EACVM,eAAMZ,EAAaa,SAAWD,IAAAA,MACtBE,EAAaD,EAAQE,KAAI,SAAAC,UAASJ,EAAMI,aACvCC,EAA2BjB,EAAYK,KAAMS,KAG3CI,EAAMR,EACNS,EAA+C,CAC1DV,KAAM,WACNE,SAAUL,GAGCc,EAAmD,CAC9DX,KAAM,QACNE,kBAASX,EAAaC,QACJA,IAAUA,aAAiBoB,QAAUpB,EAAMqB,cAAgBC,eAGnE,IAAInB,UAAUJ,EAAYK,qFAGpCO,eAAMZ,EAAaC,EAAOuB,OAClBC,EAAYxB,aAAiBoB,OAC/B,IAAIK,EAAe,QAAoCF,EAAQG,MAAO1B,GACtEuB,EAAQZ,MAAMX,EAAOuB,UAElB,IAAII,EAAkB5B,EAAYK,KAAM,CAACoB,MAGvCI,EAAgF,CAC3FpB,KAAM,QACNE,kBAASX,EAAaC,OACfA,GAASA,EAAMqB,cAAgBC,aAC5B,IAAInB,UAAUJ,EAAYK,mFAGpCO,eAAMZ,EAAaC,SAASW,IAAAA,MAAOe,IAAAA,MAC3BF,GAAYK,IADsBA,cACT7B,GAASW,EAAMX,EAAO,CAAE0B,MAAOI,IAAYnB,EAAMX,UACzE,IAAIyB,EAAe1B,EAAYK,KAAMsB,EAAOF,KAI1CO,EAAkC,CAC7CvB,KAAM,QACNE,SAAUH,EAAS,WAERyB,EAAmC,CAC9CxB,KAAM,QACNE,SAAUZ,GAECmC,EAAOD,EACPE,EAAOF,EACPG,EAA2C,CACtD3B,KAAM,QACNE,kBAASX,EAAaC,OACfC,MAAMC,QAAQF,IAA2B,IAAjBA,EAAMM,aAC3B,IAAIH,UAAUJ,EAAYK,qDAKzBgC,EAAqC,CAChD5B,KAAM,QACNE,SAAUH,EAAS,YAGR8B,EAAqC,CAChD7B,KAAM,QACNE,SApFF,SAA4BX,EAA+BC,QACnB,iBAAVA,GAAuC,iBAAVA,GAAsBA,aAAiBsC,YAGxF,IAAInC,UAAUJ,EAAYK,0EAkFvBmC,EAAMF,EACNG,EAAMD,EACNE,EAAOF,EAEPG,EAAwB,CACnClC,KAAM,SAEKmC,EAAMD,EAQNE,EAAgE,CAC3EpC,KAAM,QACNE,kBAASX,EAAaC,QACdA,aAAiBoB,SAA4B,iBAAVpB,QACjC,IAAIG,UAAUJ,EAAYK,mGAGpCO,eAAMZ,EAAa8C,EAAUtB,OACrBvB,EAA4B,iBAAb6C,EACjB,IAAIzB,OAAOyB,EAAUtB,EAAQR,MAAM+B,UAAY,IAC/CD,SACG,IAAIpB,EAAe1B,EAAYK,KAAMmB,EAAQG,MAAO1B,KAGlD8C,EAA6B,CACxCtC,KAAM,QACNG,MAAO,kBAAMoC,IAGFC,EAA6C,CACxDxC,KAAM,WACNE,SAAUH,EAAS,2MC3IR0C,iCACCC,UACVC,YAAMD,EAAc,CAClBE,oBAAqB,MACrBC,wBAAyB,SAAAjD,UAAQA,EAAKkD,MAAM,sHAIhD3C,MAAA,SACEI,EACAwC,UAEIA,GAAWA,EAAQ7B,MACd8B,EAAIC,KAAKC,oBAAoBH,EAAQ7B,MAAOX,gBAGxCJ,gBAAMI,OAhBe4C,GCXzBC,EAAyBV"}