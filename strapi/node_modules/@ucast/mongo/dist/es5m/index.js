import{optimizedCompoundCondition as e,FieldCondition as t,CompoundCondition as r,ITSELF as n,NULL_CONDITION as o,buildAnd as a,ObjectQueryParser as i}from"@ucast/core";export{defaultInstructionParsers as defaultParsers}from"@ucast/core";function f(e,t){if(!Array.isArray(t))throw new Error('"'+e.name+'" expects value to be an array')}function u(e,t){if(f(e,t),!t.length)throw new Error('"'+e.name+'" expects to have at least one element in array')}var c=function(e){return function(t,r){if(typeof r!==e)throw new Error('"'+t.name+'" expects value to be a "'+e+'"')}},p={type:"compound",validate:u,parse:function(t,r,n){var o=n.parse,a=r.map((function(e){return o(e)}));return e(t.name,a)}},s=p,l={type:"compound",validate:u},d={type:"field",validate:function(e,t){if(!(t&&(t instanceof RegExp||t.constructor===Object)))throw new Error('"'+e.name+'" expects to receive either regular expression or object of field operators')},parse:function(e,n,o){var a=n instanceof RegExp?new t("regex",o.field,n):o.parse(n,o);return new r(e.name,[a])}},v={type:"field",validate:function(e,t){if(!t||t.constructor!==Object)throw new Error('"'+e.name+'" expects to receive an object with nested query or field level operators')},parse:function(e,r,o){var a=o.parse,i=o.field,f=(0,o.hasOperators)(r)?a(r,{field:n}):a(r);return new t(e.name,i,f)}},w={type:"field",validate:c("number")},y={type:"field",validate:f},$=y,x=y,h={type:"field",validate:function(e,t){if(!Array.isArray(t)||2!==t.length)throw new Error('"'+e.name+'" expects an array with 2 numeric elements')}},m={type:"field",validate:c("boolean")},g={type:"field",validate:function(e,t){if(!("string"==typeof t||"number"==typeof t||t instanceof Date))throw new Error('"'+e.name+'" expects value to be comparable (i.e., string, number or date)')}},b=g,E=b,j=b,O={type:"field"},R=O,_={type:"field",validate:function(e,t){if(!(t instanceof RegExp)&&"string"!=typeof t)throw new Error('"'+e.name+'" expects value to be a regular expression or a string that represents regular expression')},parse:function(e,r,n){var o="string"==typeof r?new RegExp(r,n.query.$options||""):r;return new t(e.name,n.field,o)}},q={type:"field",parse:function(){return o}},A={type:"document",validate:c("function")},N=Object.freeze({__proto__:null,$and:p,$or:s,$nor:l,$not:d,$elemMatch:v,$size:w,$in:y,$nin:$,$all:x,$mod:h,$exists:m,$gte:g,$gt:b,$lt:E,$lte:j,$eq:O,$ne:R,$regex:_,$options:q,$where:A});var P=function(e){var t,r;function n(t){return e.call(this,t,{defaultOperatorName:"$eq",operatorToConditionName:function(e){return e.slice(1)}})||this}return r=e,(t=n).prototype=Object.create(r.prototype),t.prototype.constructor=t,t.__proto__=r,n.prototype.parse=function(t,r){return r&&r.field?a(this.parseFieldOperators(r.field,t)):e.prototype.parse.call(this,t)},n}(i),z=N;export{x as $all,p as $and,v as $elemMatch,O as $eq,m as $exists,b as $gt,g as $gte,y as $in,E as $lt,j as $lte,h as $mod,R as $ne,$ as $nin,l as $nor,d as $not,q as $options,s as $or,_ as $regex,w as $size,A as $where,P as MongoQueryParser,z as allParsingInstructions};
//# sourceMappingURL=index.js.map
